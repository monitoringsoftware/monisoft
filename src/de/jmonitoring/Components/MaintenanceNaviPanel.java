/*
 * MaintenanceNaviPanel.java
 *
 * Created on 11. März 2008, 17:58
 */
package de.jmonitoring.Components;

import de.jmonitoring.DataHandling.CounterChange.CounterChangeHandler;
import de.jmonitoring.DataHandling.DataHandler;
import de.jmonitoring.base.MainApplication;
import de.jmonitoring.base.Messages;
import de.jmonitoring.base.MoniSoftConstants;
import de.jmonitoring.base.sensors.SensorInformation;
import de.jmonitoring.DataHandling.CounterChange.CounterChange;
import java.awt.BasicStroke;
import java.awt.Color;
import java.text.SimpleDateFormat;
import java.util.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.jfree.chart.annotations.XYAnnotation;
import org.jfree.chart.annotations.XYPointerAnnotation;
import org.jfree.chart.plot.IntervalMarker;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.data.time.RegularTimePeriod;
import org.jfree.data.time.Second;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.ui.Layer;
import org.jfree.ui.TextAnchor;

/**
 *
 * @author togro
 */
public class MaintenanceNaviPanel extends javax.swing.JPanel {

//    TimeSeries originalSeries = null;
    ArrayList<ValueMarker> addedMarkerList = new ArrayList<ValueMarker>(500);    // neu hinzugekommene marker
    ArrayList<ValueMarker> oldMarkerList = new ArrayList<ValueMarker>(500);      // marker die aus der DB gelesen wurden
    ArrayList<ValueMarker> deletedMarkerList = new ArrayList<ValueMarker>(500);  // marker aus der db die gelöscht werden
    Boolean oldMarkersRead = false;
    BasicStroke stroke = new BasicStroke(1f);
    DocumentListener docListener = new DocumentListener() {
        @Override
        public void insertUpdate(DocumentEvent e) {
            setRangeMarker();
        }

        @Override
        public void removeUpdate(DocumentEvent e) {
            setRangeMarker();
        }

        @Override
        public void changedUpdate(DocumentEvent e) {
        }
    };
    private final MainApplication gui;

    /**
     * Creates new form MaintenanceNaviPanel
     */
    public MaintenanceNaviPanel(MainApplication gui) {
        super();
        initComponents();
        this.gui = gui;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel2 = new javax.swing.JPanel();
        firstItemButton = new javax.swing.JButton();
        prevItemButton = new javax.swing.JButton();
        nextItemButton = new javax.swing.JButton();
        lastItemButton = new javax.swing.JButton();
        markLeftButton = new javax.swing.JButton();
        markDeleteButton = new javax.swing.JButton();
        markRightButton = new javax.swing.JButton();
        ignoreItemButton = new javax.swing.JButton();
        validItemButton = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jCheckBox2 = new javax.swing.JCheckBox();
        jCheckBox1 = new javax.swing.JCheckBox();
        jTextField1 = new de.jmonitoring.utils.textfields.DoubleTextField();
        jTextField2 = new de.jmonitoring.utils.textfields.DoubleTextField();
        jLabel1 = new javax.swing.JLabel();
        jCheckBox3 = new javax.swing.JCheckBox();
        maintenanceSaveButton = new javax.swing.JButton();

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        setMaximumSize(new java.awt.Dimension(32767, 80));
        setMinimumSize(new java.awt.Dimension(0, 55));
        setPreferredSize(new java.awt.Dimension(600, 55));

        firstItemButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/resultset_first.png"))); // NOI18N
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle"); // NOI18N
        firstItemButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.firstItemButton.toolTipText")); // NOI18N
        firstItemButton.setIconTextGap(0);
        firstItemButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        firstItemButton.setMaximumSize(new java.awt.Dimension(18, 18));
        firstItemButton.setMinimumSize(new java.awt.Dimension(18, 18));
        firstItemButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                firstItemButtonActionPerformed(evt);
            }
        });

        prevItemButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/resultset_previous.png"))); // NOI18N
        prevItemButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.prevItemButton.toolTipText")); // NOI18N
        prevItemButton.setIconTextGap(0);
        prevItemButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        prevItemButton.setMaximumSize(new java.awt.Dimension(18, 18));
        prevItemButton.setMinimumSize(new java.awt.Dimension(18, 18));
        prevItemButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prevItemButtonActionPerformed(evt);
            }
        });

        nextItemButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/resultset_next.png"))); // NOI18N
        nextItemButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.nextItemButton.toolTipText")); // NOI18N
        nextItemButton.setMargin(new java.awt.Insets(1, 1, 1, 1));
        nextItemButton.setMaximumSize(new java.awt.Dimension(18, 18));
        nextItemButton.setMinimumSize(new java.awt.Dimension(18, 18));
        nextItemButton.setPreferredSize(new java.awt.Dimension(21, 21));
        nextItemButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextItemButtonActionPerformed(evt);
            }
        });

        lastItemButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/resultset_last.png"))); // NOI18N
        lastItemButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.lastItemButton.toolTipText")); // NOI18N
        lastItemButton.setMargin(new java.awt.Insets(1, 1, 1, 1));
        lastItemButton.setMaximumSize(new java.awt.Dimension(18, 18));
        lastItemButton.setMinimumSize(new java.awt.Dimension(18, 18));
        lastItemButton.setPreferredSize(new java.awt.Dimension(21, 21));
        lastItemButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                lastItemButtonActionPerformed(evt);
            }
        });

        markLeftButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/flag_blue.png"))); // NOI18N
        markLeftButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.markLeftButton.toolTipText")); // NOI18N
        markLeftButton.setMinimumSize(new java.awt.Dimension(20, 20));
        markLeftButton.setPreferredSize(new java.awt.Dimension(21, 21));
        markLeftButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                markLeftButtonActionPerformed(evt);
            }
        });

        markDeleteButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/tag_blue_delete.png"))); // NOI18N
        markDeleteButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.markDeleteButton.toolTipText")); // NOI18N
        markDeleteButton.setPreferredSize(new java.awt.Dimension(21, 21));
        markDeleteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                markDeleteButtonActionPerformed(evt);
            }
        });

        markRightButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/flag_blue.png"))); // NOI18N
        markRightButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.markRightButton.toolTipText")); // NOI18N
        markRightButton.setMaximumSize(new java.awt.Dimension(20, 20));
        markRightButton.setMinimumSize(new java.awt.Dimension(20, 20));
        markRightButton.setPreferredSize(new java.awt.Dimension(21, 21));
        markRightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                markRightButtonActionPerformed(evt);
            }
        });

        ignoreItemButton.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        ignoreItemButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/delete.png"))); // NOI18N
        ignoreItemButton.setText(bundle.getString("MaintenanceNaviPanel.ignoreItemButton.text")); // NOI18N
        ignoreItemButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.ignoreItemButton.toolTipText")); // NOI18N
        ignoreItemButton.setMargin(new java.awt.Insets(2, 1, 2, 1));
        ignoreItemButton.setPreferredSize(new java.awt.Dimension(69, 21));
        ignoreItemButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ignoreItemButtonActionPerformed(evt);
            }
        });

        validItemButton.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        validItemButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/accept.png"))); // NOI18N
        validItemButton.setText(bundle.getString("MaintenanceNaviPanel.validItemButton.text")); // NOI18N
        validItemButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.validItemButton.toolTipText")); // NOI18N
        validItemButton.setMargin(new java.awt.Insets(2, 1, 2, 1));
        validItemButton.setPreferredSize(new java.awt.Dimension(57, 21));
        validItemButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                validItemButtonActionPerformed(evt);
            }
        });

        jPanel3.setMaximumSize(new java.awt.Dimension(32767, 25));
        jPanel3.setMinimumSize(new java.awt.Dimension(100, 25));
        jPanel3.setPreferredSize(new java.awt.Dimension(971, 25));
        jPanel3.setLayout(null);

        jCheckBox2.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jCheckBox2.setText(bundle.getString("MaintenanceNaviPanel.jCheckBox2.text")); // NOI18N
        jCheckBox2.setToolTipText(bundle.getString("MaintenanceNaviPanel.jCheckBox2.toolTipText")); // NOI18N
        jCheckBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBox2ActionPerformed(evt);
            }
        });
        jPanel3.add(jCheckBox2);
        jCheckBox2.setBounds(8, 0, 160, 21);

        jCheckBox1.setFont(new java.awt.Font("Dialog", 0, 9)); // NOI18N
        jCheckBox1.setText(bundle.getString("MaintenanceNaviPanel.jCheckBox1.text")); // NOI18N
        jCheckBox1.setToolTipText(bundle.getString("MaintenanceNaviPanel.jCheckBox1.toolTipText")); // NOI18N
        jCheckBox1.setContentAreaFilled(false);
        jCheckBox1.setMaximumSize(new java.awt.Dimension(89, 20));
        jCheckBox1.setMinimumSize(new java.awt.Dimension(89, 20));
        jCheckBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBox1ActionPerformed(evt);
            }
        });
        jPanel3.add(jCheckBox1);
        jCheckBox1.setBounds(190, 0, 96, 20);

        jTextField1.setFont(new java.awt.Font("SansSerif", 0, 9)); // NOI18N
        jTextField1.setMaximumSize(new java.awt.Dimension(2147483647, 20));
        jTextField1.setMinimumSize(new java.awt.Dimension(4, 18));
        jTextField1.setPreferredSize(new java.awt.Dimension(4, 18));
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });
        jTextField1.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextField1FocusLost(evt);
            }
        });
        jPanel3.add(jTextField1);
        jTextField1.setBounds(280, 0, 63, 20);

        jTextField2.setFont(new java.awt.Font("SansSerif", 0, 9)); // NOI18N
        jTextField2.setMaximumSize(new java.awt.Dimension(2147483647, 20));
        jTextField2.setMinimumSize(new java.awt.Dimension(4, 18));
        jTextField2.setPreferredSize(new java.awt.Dimension(4, 18));
        jTextField2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField2ActionPerformed(evt);
            }
        });
        jTextField2.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextField2FocusLost(evt);
            }
        });
        jPanel3.add(jTextField2);
        jTextField2.setBounds(370, 0, 63, 20);

        jLabel1.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jLabel1.setText(bundle.getString("MaintenanceNaviPanel.jLabel1.text")); // NOI18N
        jLabel1.setIconTextGap(0);
        jPanel3.add(jLabel1);
        jLabel1.setBounds(350, 0, 20, 20);

        jCheckBox3.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jCheckBox3.setText(bundle.getString("MaintenanceNaviPanel.jCheckBox3.text")); // NOI18N
        jCheckBox3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBox3ActionPerformed(evt);
            }
        });
        jPanel3.add(jCheckBox3);
        jCheckBox3.setBounds(470, 0, 93, 21);

        maintenanceSaveButton.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        maintenanceSaveButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/jmonitoring/icons/disk.png"))); // NOI18N
        maintenanceSaveButton.setText(bundle.getString("MaintenanceNaviPanel.maintenanceSaveButton.text")); // NOI18N
        maintenanceSaveButton.setToolTipText(bundle.getString("MaintenanceNaviPanel.maintenanceSaveButton.toolTipText")); // NOI18N
        maintenanceSaveButton.setEnabled(false);
        maintenanceSaveButton.setMaximumSize(new java.awt.Dimension(60, 23));
        maintenanceSaveButton.setMinimumSize(new java.awt.Dimension(0, 0));
        maintenanceSaveButton.setPreferredSize(new java.awt.Dimension(60, 21));
        maintenanceSaveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                maintenanceSaveButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(firstItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(prevItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(nextItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lastItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(markLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(markDeleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(markRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(26, 26, 26)
                        .addComponent(ignoreItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, 209, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(validItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, 208, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 661, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(maintenanceSaveButton, javax.swing.GroupLayout.PREFERRED_SIZE, 105, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(firstItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(prevItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(nextItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lastItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(markLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(markDeleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(markRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ignoreItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(validItemButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 6, Short.MAX_VALUE))
            .addComponent(maintenanceSaveButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    private void ignoreItemButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ignoreItemButtonActionPerformed
        int iMarkerIndex = -1;
        Date sDate = new Date();
        Date eDate = new Date();
        IntervalMarker m;
        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);

        // Holen der Marker die von Beginn an (aus der DB) gestetzt waren
        if (!oldMarkersRead) { // marker wurden noch nicht gelesen
            oldMarkerList = getStatusMarkers(plot);
        }

        // Prüfen ob es einen markierten Wertebereich gibt
        IntervalMarker rangeMarker = null;
        Double lowerLimit = null;
        Double upperLimit = null;
        // Schauen ob ein RangeMarker gesetzt ist
        if (plot.getRangeMarkers(Layer.FOREGROUND) != null) {
            Vector v = new Vector(plot.getRangeMarkers(Layer.FOREGROUND));
            rangeMarker = (IntervalMarker) v.get(0);
            lowerLimit = rangeMarker.getStartValue();
            upperLimit = rangeMarker.getEndValue();
        }

        // wenn eine Zeitspanne gewählt ist alles zwischen dessen Start und Ende löschen
        if (plot.getDomainMarkers(0, Layer.FOREGROUND) != null && plot.getDomainMarkers(0, Layer.FOREGROUND).size() > 0) {
            ArrayList markers = new ArrayList(plot.getDomainMarkers(0, Layer.FOREGROUND));
            // Abfrage welchen index der Intervalmarker hat - nur dieser wird versetzt, nicht die Valuemarker
            for (int j = 0; j < markers.size(); j++) {
                if (markers.get(j).getClass() == IntervalMarker.class) {
                    iMarkerIndex = j;
                    break; // TODO Sinnvoll?
                }
            }
            m = (IntervalMarker) markers.get(iMarkerIndex); // Intervalmarker holen
            sDate.setTime((long) m.getStartValue());
            eDate.setTime((long) m.getEndValue());
            for (int i = series.getIndex(new Second(sDate)); i <= series.getIndex(new Second(eDate)); i++) {
                if ((lowerLimit != null) && (series.getValue(i).doubleValue() >= lowerLimit.doubleValue()) && (series.getValue(i).doubleValue() <= upperLimit.doubleValue())) {
                    setIgnoreMarker(series.getTimePeriod(i).getFirstMillisecond(), plot);
                } else if (lowerLimit == null) {
                    setIgnoreMarker(series.getTimePeriod(i).getFirstMillisecond(), plot);
                }
            }
        } else {    // kein IntervalMarker, nur ein einzelner Wert am Fadenkreuz
            setIgnoreMarker((long) plot.getDomainCrosshairValue(), plot);
        }

        // IntervalMarkierungen löschen
        plot.clearDomainMarkers(0);
}//GEN-LAST:event_ignoreItemButtonActionPerformed

    public ValueMarker setIgnoreMarker(long time, XYPlot plot) {
        plot.setNotify(false);
        ValueMarker vMarker = new ValueMarker(time, Color.ORANGE, stroke, null, null, 0.5f);

        // nur hinzufügen wenn nicht schon ein altern IgnoreMarker vorhanden ist
        if (!hasOldMarkerAt(time)) {
            plot.addDomainMarker(1, vMarker, Layer.BACKGROUND, false);
            addedMarkerList.add(vMarker);
        } else { // ein alter Ignoremarker ist vorhanden
            vMarker = getOldMarkerAt(time);

//            if (deletedMarkerList.contains(vMarker)) {
            if (deletedMarkerList.remove(vMarker)) { // liefert true wenn der Marker vohanden war
                vMarker.setPaint(Color.RED);
            }
            // alten Marker der auf valid gestzt wurde wieder setzen
        }

        if (deletedMarkerList.isEmpty() && addedMarkerList.isEmpty()) {
            maintenanceSaveButton.setEnabled(false);
        } else {
            maintenanceSaveButton.setEnabled(true);
        }
        plot.setNotify(true);
        return vMarker;
    }

    private void removeIgnoreMarker(ValueMarker marker, XYPlot plot) {
        plot.setNotify(false);
//        XYPlot plot = getActiveXYPlot();
        if (oldMarkerList.contains(marker)) { // es war ein alter Ignoremarker -> grün färben
            marker.setPaint(Color.GREEN);
            deletedMarkerList.add(marker);
        } else { // ein neu gesetzter Marker wird wieder gelöscht
            plot.removeDomainMarker(1, marker, Layer.BACKGROUND, false);
            addedMarkerList.remove(marker);
        }

        if (deletedMarkerList.isEmpty() && addedMarkerList.isEmpty()) {
            maintenanceSaveButton.setEnabled(false);
        } else {
            maintenanceSaveButton.setEnabled(true);
        }
        plot.setNotify(true);
    }

    private void prevItemButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prevItemButtonActionPerformed
        // Datenpunkt davor
        long x;
        boolean skip = true;
        RegularTimePeriod p = null;
        Date date = new Date();
        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);
        x = (long) plot.getDomainCrosshairValue();
        date.setTime(x);
        int index = series.getIndex(new Second(date));

//        if (getStatusMarkers(plot).size() > 0) {
        while (skip) {
            index = index - 1;
            if (index == 0) {
                return;
            }
            p = series.getDataItem(index).getPeriod();
            if (getStatusMarkers(plot).size() > 0) {
                for (Object valm : getStatusMarkers(plot)) {
                    skip = false;
                    if (p.getFirstMillisecond() == ((ValueMarker) valm).getValue()) {
                        skip = true;
                        break;
                    }
                }
            } else {
                skip = false;
            }
        }
        date.setTime(p.getFirstMillisecond());
        plot.setDomainCrosshairValue((double) date.getTime());
        plot.setRangeCrosshairValue((Double) series.getValue(index));
    }//GEN-LAST:event_prevItemButtonActionPerformed

    private void nextItemButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextItemButtonActionPerformed
        // Datenpunkt danach
        long x;
        boolean skip = true;
        RegularTimePeriod p = null;
        Date date = new Date();
        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);
        x = (long) plot.getDomainCrosshairValue();
        date.setTime(x);
        int index = series.getIndex(new Second(date));
        while (skip) {
            index = index + 1;
            if (index == series.getItemCount()) {
                return;
            }
            p = series.getDataItem(index).getPeriod();
            if (getStatusMarkers(plot).size() > 0) {
                for (Object valm : getStatusMarkers(plot)) {
                    skip = false;
                    if (p.getFirstMillisecond() == ((ValueMarker) valm).getValue()) {
                        skip = true;
                        break;
                    }
                }
            } else {
                skip = false;
            }
        }

        date.setTime(p.getFirstMillisecond());
        plot.setDomainCrosshairValue((double) date.getTime());
        plot.setRangeCrosshairValue((Double) series.getValue(index));
    }//GEN-LAST:event_nextItemButtonActionPerformed

    private void maintenanceSaveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_maintenanceSaveButtonActionPerformed
        Thread doDBUpdateThread = new doDBUpdate();
        doDBUpdateThread.setName("MaintenanceDBUpdateThread");
        doDBUpdateThread.start();
//        doDBUpdateThread = null;

        maintenanceSaveButton.setEnabled(false);
    }//GEN-LAST:event_maintenanceSaveButtonActionPerformed

    private void markLeftButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_markLeftButtonActionPerformed
        setIntervalMarkers(MoniSoftConstants.LEFT);
    }//GEN-LAST:event_markLeftButtonActionPerformed

    private void markDeleteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_markDeleteButtonActionPerformed
        XYPlot plot = getActiveXYPlot();
        plot.clearDomainMarkers(0);
    }//GEN-LAST:event_markDeleteButtonActionPerformed

    private void markRightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_markRightButtonActionPerformed
        setIntervalMarkers(MoniSoftConstants.RIGHT);
    }//GEN-LAST:event_markRightButtonActionPerformed

    private void validItemButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_validItemButtonActionPerformed
        XYPlot plot = getActiveXYPlot();
        plot.setNotify(false);
        ArrayList markerList = new ArrayList(500);
        int iMarkerIndex = -1;
        ValueMarker mark;
        IntervalMarker m;

        // Holen der Marker die von Beginn an (aus der DB) gesetzt waren
        if (!oldMarkersRead) { // sie wurden bisher noch nicht gelesen
            oldMarkerList = getStatusMarkers(plot);
        }

        // Liste aller StatusMarker holen (wird immer ausgeführt, daher auch die neuen enthalten)
        markerList = getStatusMarkers(plot);

        // wenn ein Intervalmarker gesetzt ist alle darin vorhandenen ValueMarker löschen
        if (plot.getDomainMarkers(0, Layer.FOREGROUND) != null && plot.getDomainMarkers(0, Layer.FOREGROUND).size() > 0) {
            ArrayList rangeMarkerList = new ArrayList(plot.getDomainMarkers(0, Layer.FOREGROUND)); // den rangemarker des gewählten Zeitraums ermitteln
            for (int j = 0; j < rangeMarkerList.size(); j++) { // wird max. 3 mal durchlaufen
                if (rangeMarkerList.get(j).getClass() == IntervalMarker.class) {
                    iMarkerIndex = j;
                }
            }
            m = (IntervalMarker) rangeMarkerList.get(iMarkerIndex); // Intervalmarker holen
            Iterator<ValueMarker> it = markerList.iterator();
            while (it.hasNext()) {
                mark = it.next();
                if ((mark.getValue() >= m.getStartValue()) && (mark.getValue() <= m.getEndValue())) {
                    removeIgnoreMarker(mark, plot);
                }
            }
        } else { // kein Intervalmarker gesetzt, nur den Marker am Crosshair löschen
            long x = (long) plot.getDomainCrosshairValue();
            Iterator<ValueMarker> it = markerList.iterator();
            while (it.hasNext()) {
                mark = it.next();
                if (mark.getValue() == (double) x) {
                    removeIgnoreMarker(mark, plot);
                }
            }
        }
        plot.clearDomainMarkers(0);
        plot.setNotify(true);
}//GEN-LAST:event_validItemButtonActionPerformed

    private void firstItemButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_firstItemButtonActionPerformed
        // erster Datenpunkt
        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);
        plot.setDomainCrosshairValue(series.getTimePeriod(0).getFirstMillisecond());
        plot.setRangeCrosshairValue((Double) series.getValue(series.getTimePeriod(0)));
}//GEN-LAST:event_firstItemButtonActionPerformed

    private void lastItemButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_lastItemButtonActionPerformed
        // letzter Datenpunkt
        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);
        plot.setDomainCrosshairValue(series.getTimePeriod(series.getItemCount() - 1).getFirstMillisecond());
        plot.setRangeCrosshairValue((Double) series.getValue(series.getTimePeriod(series.getItemCount() - 1)));
}//GEN-LAST:event_lastItemButtonActionPerformed

private void jCheckBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox1ActionPerformed
    setRangeMarker();
}//GEN-LAST:event_jCheckBox1ActionPerformed

private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField1ActionPerformed
    setRangeMarker();
}//GEN-LAST:event_jTextField1ActionPerformed

private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField2ActionPerformed
    setRangeMarker();
}//GEN-LAST:event_jTextField2ActionPerformed

private void jTextField1FocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextField1FocusLost
    setRangeMarker();
}//GEN-LAST:event_jTextField1FocusLost

private void jTextField2FocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextField2FocusLost
    setRangeMarker();
}//GEN-LAST:event_jTextField2FocusLost

private void jCheckBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox2ActionPerformed
    // Faktoren anbringen oder wegnehmen
    useFactors();
    showAnnotations();
}//GEN-LAST:event_jCheckBox2ActionPerformed

private void jCheckBox3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox3ActionPerformed
    // Anmerkungen zeigen oder verbergen
    showAnnotations();
}//GEN-LAST:event_jCheckBox3ActionPerformed

    private void useFactors() {
        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);

        Double sensorFactor = SensorInformation.getSensorProperties(SensorInformation.getSensorIDFromNameORKey(series.getKey().toString())).getFactor();
        TreeMap<Long, Double> factorMap = SensorInformation.getFactorList(SensorInformation.getSensorIDFromNameORKey(series.getKey().toString()));

        if (sensorFactor == 1d && factorMap.isEmpty()) {
            return; // es gibt nichts zu tun
        }

        Double factor = sensorFactor; // vorbelegen mit dem Faktor aus der Sensorliste
//        System.out.println("sensorfactor " + sensorFactor);
        Double useFactor;
        for (int i = 0; i < series.getItemCount(); i++) {
            if (!factorMap.isEmpty() && series.getDataItem(i).getPeriod().getFirstMillisecond() >= factorMap.firstKey()) {
                factor = factorMap.pollFirstEntry().getValue(); // Liefert den kleinsten Eintrag in der map und löscht ihn dann.
//                System.out.println("poll " + factor);
            }

            if (jCheckBox2.isSelected()) { // Faktor anbringen
                useFactor = factor;
            } else {
                useFactor = 1. / factor;
            }

//            System.out.println("using Factor " + useFactor);
            series.update(i, series.getDataItem(i).getValue().doubleValue() * useFactor);
        }
        series.fireSeriesChanged();
    }

    private void showAnnotations() {
        XYPlot plot = getActiveXYPlot();

        // remove all existsin annotations
        for (Object a : plot.getAnnotations()) {
            plot.removeAnnotation((XYAnnotation) a);
        }

        if (jCheckBox3.isSelected()) { // user wants annotations
            TimeSeries series = getActiveSeries(plot);

            // collect for factor changes
            Double sensorFactor = SensorInformation.getSensorProperties(SensorInformation.getSensorIDFromNameORKey(series.getKey().toString())).getFactor();
            TreeMap<Long, Double> factorMap = SensorInformation.getFactorList(SensorInformation.getSensorIDFromNameORKey(series.getKey().toString()));

            // collect for counter changes
            CounterChangeHandler ch = new CounterChangeHandler();
            ArrayList<CounterChange> changes = ch.getCounterChanges(SensorInformation.getSensorIDFromNameORKey(series.getKey().toString()));
            TreeSet<Long> changeTimeMap = new TreeSet<Long>();
            for (CounterChange change : changes) {
                changeTimeMap.add(change.getTime().getTime());
            }

            if (sensorFactor == 1. && factorMap.isEmpty() && changes.isEmpty()) {
                return; // nothing to do: no factor or counter changes and the factor is 1, don't show it
            }

            Double factor;
            // loop through all datapoints in the series
            for (int i = 0; i < series.getItemCount(); i++) {
                String factorText = "";
                String factorTooltip = "";
                String changeTooltip = "";
                String changeText = "";
                String showText = "";
                String showTooltip = "";

                // look for factor changes
                if (!factorMap.isEmpty() && series.getDataItem(i).getPeriod().getFirstMillisecond() >= factorMap.firstKey()) {
                    factor = factorMap.pollFirstEntry().getValue(); // Liefert den kleinsten Eintrag in der map und löscht ihn dann.
                    factorText = java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle").getString("ManualNaviPanel.FACTOR") + " " + factor;
                    factorTooltip = java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle").getString("ManualNaviPanel.FACTOR") + " " + factor + " " + java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle").getString("MaintenanceNaviPanel.FROM") + " " + new SimpleDateFormat(MoniSoftConstants.HumanDateTimeFormat).format(new Date(series.getDataItem(i).getPeriod().getFirstMillisecond()));
                }

                // look for counter changes
                if (!changeTimeMap.isEmpty() && series.getDataItem(i).getPeriod().getFirstMillisecond() >= changeTimeMap.first()) {
                    changeTimeMap.pollFirst();
                    changeTooltip = java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle").getString("MaintenanceNaviPanel.COUNTERCHANGE") + " " + java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle").getString("MaintenanceNaviPanel.AT") + " " + new SimpleDateFormat(MoniSoftConstants.HumanDateTimeFormat).format(new Date(series.getDataItem(i).getPeriod().getFirstMillisecond()));
                    changeText = java.util.ResourceBundle.getBundle("de/jmonitoring/Components/Bundle").getString("MaintenanceNaviPanel.COUNTERCHANGE");
                }

                // if there is a counter change there will automatically be a factor change. only show the counter chnage.
                if (!changeText.isEmpty()) {
                    showText = changeText;
                    showTooltip = changeTooltip;
                } else {
                    showText = factorText;
                    showTooltip = factorTooltip;
                }

                // if there is a annotation: add it
                if (!showText.isEmpty()) {
                    XYPointerAnnotation changePointer = new XYPointerAnnotation(showText, series.getDataItem(i).getPeriod().getFirstMillisecond(), series.getDataItem(i).getValue().doubleValue(), 2. * Math.PI);
                    changePointer.setArrowWidth(5);
                    changePointer.setTipRadius(2);
                    changePointer.setArrowPaint(Color.RED);
                    changePointer.setArrowLength(5);
                    changePointer.setArrowStroke(new BasicStroke(2));
                    changePointer.setBackgroundPaint(new Color(255, 255, 68));
                    changePointer.setTextAnchor(TextAnchor.CENTER_LEFT);
                    changePointer.setToolTipText(showTooltip);
                    plot.addAnnotation(changePointer);
                }
            }
            series.fireSeriesChanged();
        }
    }

    private void setRangeMarker() {
        XYPlot plot = getActiveXYPlot();
        plot.clearRangeMarkers();

        if (jCheckBox1.isSelected()) {
            try {
                IntervalMarker marker = new IntervalMarker(Double.valueOf(jTextField1.getText()), Double.valueOf(jTextField2.getText()));
                marker.setPaint(Color.RED);
                marker.setAlpha(0.3f);
                marker.setStroke(new BasicStroke(2));
                plot.addRangeMarker(marker, Layer.FOREGROUND);
            } catch (NumberFormatException e) {
                Messages.showException(e);
                jCheckBox1.setSelected(false);
            }
        }
    }

    private XYPlot getActiveXYPlot() {
        System.out.println();
        return (XYPlot) this.gui.getActiveChart().getPlot();
    }

    private TimeSeries getActiveSeries(XYPlot plot) {
        TimeSeriesCollection seriesCollection = (TimeSeriesCollection) plot.getDataset();
        TimeSeries series = (TimeSeries) seriesCollection.getSeries(0);
        return series;
    }

    public interface ProgressListener {

        public void startProgress(int min, int max, String initialText);

        public void setProgress(int progressCount, String text);

        public void endProgess();
    }

    private static class ProgressBarProgessListener implements ProgressListener {

        MoniSoftProgressBar progressBar;
        private final MainApplication gui;

        public ProgressBarProgessListener(MainApplication gui) {
            this.gui = gui;
        }

        @Override
        public void startProgress(int min, int max, String initialText) {
            progressBar = this.gui.getProgressBarpanel().addProgressBar("Mark invalid");
            progressBar.setMinMax(min, max);
            progressBar.setValue(min);
        }

        @Override
        public void setProgress(int progressCount, String text) {
            progressBar.setValue(progressCount);
            progressBar.setText(text);
        }

        @Override
        public void endProgess() {
            progressBar.remove();
        }
    }

    class doDBUpdate extends Thread {

        XYPlot plot = getActiveXYPlot();
        TimeSeries series = getActiveSeries(plot);
        DataHandler handler = new DataHandler(SensorInformation.getSensorFromDisplayName((String) series.getKey()).getSensorID());

        public doDBUpdate() {
        }

        @Override
        public void run() {
            // Ursprüngliche Ignoremarker die jetzt gelöscht werden (aus DB)
            if (!deletedMarkerList.isEmpty()) {
                for (ValueMarker marker : deletedMarkerList) {
                    plot.removeDomainMarker(1, marker, Layer.BACKGROUND);
                }
                handler.markValidAll(deletedMarkerList);
            }

            // neu hinzu gekommene Marker die in DB eingetragen werden
            if (!addedMarkerList.isEmpty()) {
                for (ValueMarker marker : addedMarkerList) {
                    marker.setPaint(Color.RED);
                }
                ProgressBarProgessListener progessListener = new ProgressBarProgessListener(gui);
                handler.markIgnoreAll(addedMarkerList, progessListener);
            }

            handler = null;
            addedMarkerList.clear();
            deletedMarkerList.clear();
            oldMarkerList = getStatusMarkers(plot);
            maintenanceSaveButton.setEnabled(true);
        }
    }

    /**
     * Setzt die Marker für die Bereichsauswahl durch den Nutzer
     *
     * @param side
     */
    private void setIntervalMarkers(int side) {
        int iMarkerIndex = -1;
        IntervalMarker m;
        XYPlot plot = getActiveXYPlot();
        long x = (long) plot.getDomainCrosshairValue();

        // Wenn Marker vorhanden sind
        if (plot.getDomainMarkers(0, Layer.FOREGROUND) != null && plot.getDomainMarkers(0, Layer.FOREGROUND).size() > 0) {
            ArrayList markers = new ArrayList(plot.getDomainMarkers(0, Layer.FOREGROUND));
            // Abfrage welchen index der Intervalmarker hat - nur dieser wird versetzt
            for (int j = 0; j < markers.size(); j++) {
                if (markers.get(j).getClass() == IntervalMarker.class) {
                    iMarkerIndex = j;
                    break;
                }
            }
            m = (IntervalMarker) markers.get(iMarkerIndex); // Intervalmarker holen
            if (x < m.getEndValue() && side == MoniSoftConstants.LEFT) {
                m.setStartValue((double) x);
            } else if (x > m.getStartValue() && side == MoniSoftConstants.RIGHT) {
                m.setEndValue((double) x);
            }
            plot.clearDomainMarkers(0);
            plot.addDomainMarker(0, m, Layer.FOREGROUND);
            plot.addDomainMarker(0, new ValueMarker(m.getStartValue(), Color.BLUE, new BasicStroke(2)), Layer.FOREGROUND);
            plot.addDomainMarker(0, new ValueMarker(m.getEndValue(), Color.BLUE, new BasicStroke(2)), Layer.FOREGROUND);
        } else {
            IntervalMarker mark = new IntervalMarker((double) x, (double) x);
            plot.addDomainMarker(0, new ValueMarker((double) x, Color.BLUE, new BasicStroke(2)), Layer.FOREGROUND);
            mark.setPaint(Color.BLUE);
            mark.setAlpha(0.08f);
            plot.addDomainMarker(0, mark, Layer.FOREGROUND);
        }
    }

    /**
     * Methode getStatusMarkers Holt alle Statusmarker des Plots
     *
     * @return list Liste der Statusmarker
     */
    private ArrayList getStatusMarkers(XYPlot plot) {
        ArrayList list = new ArrayList();
        plot = plot == null ? getActiveXYPlot() : plot;
        if (plot.getDomainMarkers(1, Layer.BACKGROUND) != null) {
            list.addAll(plot.getDomainMarkers(1, Layer.BACKGROUND));
        }
        oldMarkersRead = true;
        return list;
    }

    /**
     * Methode hasOldMarkers Überprüft ob an der gegeben Stelle ein alter Marker
     * gesetzt ist
     *
     * @param time Der zu Überprüfende Zeitpunkt
     * @return hasNext Wahrheitswert ob Marker vorhanden
     */
    private boolean hasOldMarkerAt(long time) {
        boolean hasMarker = false;
        if ((oldMarkerList == null) || (oldMarkerList.isEmpty())) {
            hasMarker = false;
        } else {
            Iterator<ValueMarker> it = oldMarkerList.iterator();
            while (it.hasNext()) {
                if (time == it.next().getValue()) {
                    hasMarker = true;
                }
            }
        }
        return hasMarker;
    }

    /**
     * Methode getOldMarkerAt Gibt den alten Marker an der Stalle time zurück
     *
     * @param time Der zu überprüfende Zeitpunkt
     * @return m Marker an der Stelle time (oder null)
     */
    private ValueMarker getOldMarkerAt(long time) {
        ValueMarker m;
        Iterator<ValueMarker> it = oldMarkerList.iterator();
        while (it.hasNext()) {
            m = it.next();
            if (time == m.getValue()) {
                return m;
            }
        }
        return null;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton firstItemButton;
    private javax.swing.JButton ignoreItemButton;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JCheckBox jCheckBox3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JButton lastItemButton;
    private javax.swing.JButton maintenanceSaveButton;
    private javax.swing.JButton markDeleteButton;
    private javax.swing.JButton markLeftButton;
    private javax.swing.JButton markRightButton;
    private javax.swing.JButton nextItemButton;
    private javax.swing.JButton prevItemButton;
    private javax.swing.JButton validItemButton;
    // End of variables declaration//GEN-END:variables
}
